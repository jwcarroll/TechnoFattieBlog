---
layout: post
title: It's The Principal...
tags: [c#,dot-net,security,unit-testing,tdd]
alias: /2012/01/its-principal.html
---

In ancient times... at least according to web standards, I wrote a <a href="http://technofattie.blogspot.com/2011/02/unit-testing-and-declarative-security.html"">couple of posts</a> about <a href="http://technofattie.blogspot.com/2011/04/unit-testing-and-declarative-security.html">unit testing with declarative security attributes</a>. It turns out that while using declarative security is pretty awesome, it's clear <i>nobody</i>&nbsp;was thinking about people doing TDD :(<div><br /></div><div>Getting around this was easy enough by simply overriding the <a href="http://msdn.microsoft.com/en-us/library/system.threading.thread.currentprincipal.aspx">Principal</a> using the built in <a href="http://msdn.microsoft.com/en-us/library/system.security.principal.genericprincipal.aspx">GenericPrincipal</a> and <a href="http://msdn.microsoft.com/en-us/library/system.security.principal.genericidentity.aspx">GenericIdentity</a> classes. We even refactored the security setup code into the Initialize method for our unit tests. However, <b>we still had to think about security for every test class!</b></div><div><b><br /></b></div><div>I can tell you right now that that is a big fat suck! I don't want to see <i>any</i>&nbsp;security related code in my unit test because <b>I'm not testing security right now!</b>&nbsp;What I really want is for my test to look like this and just work.</div><div><br /></div><div><pre><code>[TestMethod]<br />public void ShouldGetSuperSecretFromAgent()<br />{<br />    var agent = new SecretAgent();<br /><br />    //This line will esplode!!!<br />    var secret = agent.GetSuperSecretStuff();<br /><br />    Assert.IsNotNull(secret);<br />}<br /></code></pre></div><div><br /></div><div>Fortunately, we still have one last trick up our sleeve that we can use to solve our problem once and for all. Writing a custom implementation of <a href="http://msdn.microsoft.com/en-us/library/system.security.principal.iprincipal.aspx">IPrincipal</a> and <a href="http://msdn.microsoft.com/en-us/library/system.security.principal.iidentity.aspx">IIdentity</a>. This is so braindead simple, that I'm not even going to explain it... just show you the code.</div><div><br /></div><div><pre><code><br />public class StubPrincipal: IPrincipal, IIdentity<br />{<br />    public StubPrincipal(String name = "TestUser", Boolean isAuthenticated = true, String authenticationType = "Fake")<br />    {<br />        Name = name;<br />        IsAuthenticated = isAuthenticated;<br />        AuthenticationType = authenticationType;<br />    }<br /><br />    //IPrincipal Members<br />    public IIdentity Identity<br />    {<br />        get { return this; }<br />    }<br /><br />    public bool IsInRole(string role)<br />    {<br />        return true;<br />    }<br /><br />    //IIdentity Members<br />    public string AuthenticationType { get; set; }<br /><br />    public bool IsAuthenticated { get; set; }<br /><br />    public string Name { get; set; }<br />}</code></pre></div><div><br /></div><div>This still leaves the business of wiring it all up. Since the whole point of this refactoring was to <i>not</i>&nbsp;have to worry about doing this for every test!</div><div><br /></div><div><b>All your base class are belong to us!</b></div><div><b><br /></b></div><div>The simplest approach I can think of is to create a base class that will wire up your custom <b>StubPrincipal</b> object in the constructor, and then derive all your test classes from it. Again, this is so braindead simple... just look at the code.</div><div><br /></div><div><pre><code><br />public class SecurityEnabledTest<br />{<br />    protected StubPrincipal Principal = new StubPrincipal();<br /><br />    public SecurityEnabledTest()<br />    {<br />        Thread.CurrentPrincipal = Principal;<br />    }<br />}<br /></code></pre></div><div><br /></div><div>And now our goal above is reached with one tiny modification.</div><div><br /></div><div><pre><code><br />[TestClass]<br />public class SecretAgentBehavior_UsingBaseClass: SecurityEnabledTest<br />{<br />    [TestMethod]<br />    [Description("Test relying on base class to set principal")]<br />    public void ShouldGetSuperSecretFromAgent()<br />    {<br />        var agent = new SecretAgent();<br /><br />        //It works... WOOT!<br />        var secret = agent.GetSuperSecretStuff();<br /><br />        Assert.IsNotNull(secret);<br />    }<br />}<br /></code></pre></div><div><br /></div><div>Voila! Now you can go on your merry little way and focus on the actual method behavior instead of the security meta-data.</div><div><br /></div><div><b>But Wait! There is even more awesome!</b></div><div><b><br /></b></div><div>If you are thinking to yourself "Ok, that is great dude, but what if I actually want to test MY FREAKING SECURITY!"</div><div><br /></div><div>I've got you covered. Here is a slightly <a href="https://gist.github.com/1708922">more robust Principal object</a> that will give you a lot more control over how it behaves, which should cover any testing scenario you can think of. It allows you to add roles, and has three modes of operation:</div><div><ol><li>Always Return True</li><li>Whitelist</li><ol><li>This is how a normal principal operates. If the role is in the list, then you get access.</li></ol><li>Blacklist</li><ol><li>This works opposite to a normal principal. If the role is in the list, then you get denied access. This is useful for when there are multiple roles needed to perform an action (think nested calls), and you want to see how your code behaves when the user <i>doesn't</i>&nbsp;have one of them.</li></ol></ol><div>In the end I hope this helps unit testing efforts, and maybe demystifies the Principal/Identity objects a little bit. You can even use these same techniques to write your own custom security Principal for actual production uses. The concepts are identical.</div></div><div><br /></div><div>Cheers,</div><div>Josh</div>
