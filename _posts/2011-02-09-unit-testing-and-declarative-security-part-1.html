---
layout: post
title: Unit Testing and Declarative Security, Part 1
tags: [c#,dot-net,security,unit-testing,tdd]
alias: /2011/02/unit-testing-and-declarative-security.html
---

<ul><li><a href="http://technofattie.blogspot.com/2011/04/unit-testing-and-declarative-security.html">See Part 2</a></li><li><a href="http://technofattie.blogspot.com/2012/01/its-principal.html">And Part 3</a></li></ul><br />Security is hard. If you think it isn't your software is probably just waiting to be exploited by this guy:<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-LFBH0lmiDZk/TVNtn_VV0aI/AAAAAAAAA1k/f72-ZNQtWSM/s1600/EvilHacker.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://1.bp.blogspot.com/-LFBH0lmiDZk/TVNtn_VV0aI/AAAAAAAAA1k/f72-ZNQtWSM/s1600/EvilHacker.jpg" /></a></div><br /><br />Knowing this, the guys who put together the .Net framework gave us a pretty brain-dead approach to adding security declaratively<sup>1</sup> to our code using the <a href="http://msdn.microsoft.com/en-us/library/system.security.permissions.principalpermissionattribute.aspx">PrincipalPermissionAttribute</a>. Securing a method call becomes trivial this way.<br /><br /><pre><code>[PrincipalPermission(SecurityAction.Demand, Authenticated = true, Role = "007")]<br />public Secret GetSuperSecretStuff(){<br />    return Vault.SuperSecret;<br />}<br /></code></pre><br />Anybody who calls this method will have to be operating under a security context that is both authenticated and a member of the <span class="Apple-style-span" style="color: #990000;">"007"</span> role. However, calling this method without meeting the requirements will throw a big fat Exception. This can make unit testing a bit tricky since you most likely will <strong>not</strong> have the proper credentials. <br /><br />For instance suppose the above method were defined on a <span class="Apple-style-span" style="background-color: #cccccc; font-family: 'Courier New', Courier, monospace;">SecretAgent</span> type in my project and I wanted to write a unit test for it:<br /><br /><pre><code>[TestMethod]<br />public void ShouldGetSuperSecretFromAgent()<br />{<br />    var agent = new SecretAgent();<br /><br />    var secret = agent.GetSuperSecretStuff();<br /><br />    Assert.IsNotNull(secret);<br />}<br /></code></pre><br />Running this code will result in a big fat exception, and your test output will read:<br /><br /><blockquote><span class="Apple-style-span" style="background-color: #fff2cc; font-size: large;">Test method TechnoFattie.Lib.Tests.SecretAgentBehavior.ShouldGetSuperSecretFromAgent threw exception: </span><br /><span class="Apple-style-span" style="background-color: #fff2cc; font-size: large;">System.Security.SecurityException: Request for principal permission failed.</span></blockquote><br />Bummer :(<br /><br /><b>Getting around this is pretty easy though if you understand how security works in the .Net framework.<br /></b><br />Most security in .Net is centered around checking the <a href="http://msdn.microsoft.com/en-us/library/system.threading.thread.currentprincipal.aspx">Principal on the currently executing thread</a> to see if it contains a specific role, and using the <span class="Apple-style-span" style="background-color: #cccccc; font-family: 'Courier New', Courier, monospace;">PrincipalPermissionAttribute</span> is no exception.<br /><br />You could think of using security declared in this way as having wrapped every call to <span class="Apple-style-span" style="background-color: #cccccc; font-family: 'Courier New', Courier, monospace;">GetSuperSecretStuff</span> like this:<br /><br /><pre><code>if(Thread.CurrentPrincipal.IsInRole("007")){<br />    var secret = GetSuperSecretStuff();<br />}<br />else{<br />    throw new SecurityException("Request for principal permission failed.");<br />}<br /></code></pre><br />What we need is a way to completely control the Principal. Fortunately for us, replacing the principal is as simple as setting a property. You can assign any principal you want to <span class="Apple-style-span" style="background-color: #cccccc; font-family: 'Courier New', Courier, monospace;">Thread.Current.Principal</span> so long as it implements the <a href="http://msdn.microsoft.com/en-us/library/system.security.principal.iprincipal.aspx">IPrincipal</a> interface.<br /><br />If we look the <span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;"><span class="Apple-style-span" style="background-color: #cccccc;">IPrincipal</span> </span>interface, we will notice it is pretty darn simple:<br /><br /><pre><code>public interface IPrincipal<br />{<br />    IIdentity Identity { get; }<br />    bool IsInRole(string role);<br />}<br /></code></pre><br />You will also notice that it contains an <span class="Apple-style-span" style="background-color: #cccccc; font-family: 'Courier New', Courier, monospace;">Identity</span> property, another very simple interface:<br /><br /><pre><code>public interface IIdentity<br />{<br />    string AuthenticationType { get; }<br />    bool IsAuthenticated { get; }<br />    string Name { get; }<br />}<br /></code></pre><br />We could implement our own classes here and use them, but I generally prefer the path of laziness. And wouldn't you know it, the hard working guys at Microsoft decided they would spare us the grueling work of implementing three entire properties and one method. Having pity on the lesser developers like myself, they gave us...<br /><br /><a href="http://msdn.microsoft.com/en-us/library/system.security.principal.genericprincipal.aspx">GenericPrincipal</a> and <a href="http://msdn.microsoft.com/en-us/library/system.security.principal.genericidentity.aspx">GenericIdentity</a><br /><br />Standing on the shoulders of these giants we can rewrite our test method to take advantage of the no doubt hundreds of man hours required to not only implement these classes, but to carefully name them as well.<br /><br /><pre><code>[TestMethod]<br />public void ShouldGetSuperSecretFromAgentUsingGenericPrincipalAndIdentity()<br />{<br />    var awesomeSauce = new GenericPrincipal(<br />            new GenericIdentity("jbond"), new[] { "007" }<br />        );<br /><br />    Thread.CurrentPrincipal = awesomeSauce;<br /><br />    var agent = new SecretAgent();<br /><br />    var secret = agent.GetSuperSecretStuff();<br /><br />    Assert.IsNotNull(secret);<br />}<br /></code></pre><br />Now our test will happily pass, and life is good once again. Security can seem like a somewhat mystical thing in .Net, but as you can see the underlying mechanics are pretty simple. <a href="http://technofattie.blogspot.com/2011/04/unit-testing-and-declarative-security.html">In the next installment</a> I am actually going to implement a custom Principal type in order to be able to test more complicated security scenarios, and to reduce the amount of code needed to ease maintenance.<br /><br /><span class="Apple-style-span" style="font-size: x-small;"><i>1. Don't mistake this approach for a real security solution however.  Ideally you should have already checked the user's credentials before hand and the method would never get called. This method is really only good as a fail-safe.</i></span>
