---
layout: post
title: Unit Testing and Declarative Security, Part 2
---

<ul><li><a href="http://technofattie.blogspot.com/2011/02/unit-testing-and-declarative-security.html">See Part 1</a></li><li><a href="http://technofattie.blogspot.com/2012/01/its-principal.html">And Part 3</a></li></ul><br /><a href="http://technofattie.blogspot.com/2011/02/unit-testing-and-declarative-security.html">In a previous post</a> I talked about using the <a href="http://msdn.microsoft.com/en-us/library/system.security.permissions.principalpermissionattribute.aspx">PrincipalPermissionAttribute</a> to achieve some last resort security that was tightly integrated into the framework.<br /><br />The nice thing about this approach is that you don't have to worry about some other programmer forgetting to check security before calling a method in your API. The bad news is because of the tight integration, Unit Testing becomes a little tricker. Since there is not a security service to mock, we have to get our hands dirty and actually set the <a href="http://msdn.microsoft.com/en-us/library/system.threading.thread.currentprincipal.aspx">Principal</a> so the method calls won't fail at runtime.<br /><br />We got around this last time by using <a href="http://msdn.microsoft.com/en-us/library/system.security.principal.genericprincipal.aspx">GenericPrincipal</a> and <a href="http://msdn.microsoft.com/en-us/library/system.security.principal.genericidentity.aspx">GenericIdentity</a>, two classes provided for us by the FCL writers. However, the added code distracts from the test we really want to write. Lets look at that example again.<br /><br /><pre><code>[TestMethod]<br />public void ShouldGetSuperSecretFromAgentUsingGenericPrincipalAndIdentity()<br />{<br />    var awesomeSauce = new GenericPrincipal(<br />            new GenericIdentity("jbond"), new[] { "007" }<br />        );<br /><br />    Thread.CurrentPrincipal = awesomeSauce;<br /><br />    var agent = new SecretAgent();<br /><br />    var secret = agent.GetSuperSecretStuff();<br /><br />    Assert.IsNotNull(secret);<br />}<br /></code></pre><br />So this isn't terrible right now, but it is code that will have to be repeated over and over again for each test that calls that method. In this scenario we really aren't interested in testing the security, but rather the guts of the method. We want to test security, but not in this method. Ok, let's start DRYing up this code.<br /><br />The easiest and simplest choice would be to just refactor out the code into a method, and then call it before our test. This is simple enough to do.<br /><br /><pre><code>[TestMethod]<br />public void ShouldGetSuperSecretFromAgentUsingGenericPrincipalAndIdentity()<br />{<br />    SetUserRoles("007");<br /><br />    var agent = new SecretAgent();<br /><br />    var secret = agent.GetSuperSecretStuff();<br /><br />    Assert.IsNotNull(secret);<br />}<br /><br />private void SetUserRoles(params String[] roles)<br />{<br />    if(roles == null || roles.Length == 0) return;<br /><br />    var principal = new GenericPrincipal(<br />            new GenericIdentity("jbond"), roles<br />        );<br /><br />    Thread.CurrentPrincipal = principal;<br />}<br /></code></pre><br />That is slightly better, and gives a much better indication of what is going on when looking at the test, but I still don't like it for a couple of reasons:<br /><br /><ul><li>The call to SetUserRoles still takes away from the purpose of the test. Remember this test isn't about security, but the behavior of the method itself. Everytime you look at this test you will first have to figure out why the security is there, and this increases friction and slows down the <a href="http://jamesshore.com/Blog/Red-Green-Refactor.html">RED/GREEN/REFACTOR</a> cycle.</li><li>Code is still repeated because everytime we test a path through any method with security we will have to make a call to SetUserRoles, and that sucks. Any code that can be copied and pasted is worth your time to refactor.</li></ul><br />I really want to get to not thinking about security when I write my tests, so let's see if we can at least do that. Those of you familiar with any of the major <a href="http://www.nunit.org/">Unit</a> <a href="http://www.gallio.org/">Testing</a> <a href="http://msdn.microsoft.com/en-us/library/ms182486.aspx">Frameworks</a> will know that they all have an attribute that designates one method that will run before every test is run. In MSTest it is the <a href="http://msdn.microsoft.com/en-us/library/microsoft.visualstudio.testtools.unittesting.testinitializeattribute(v=VS.100).aspx">TestInitializeAttribute</a>. We can use that to neatly tuck our security code away into a single method so we don't have to repeat it for every test.<br /><br /><br /><pre><code>[TestInitialize]<br />public void Init()<br />{<br />    SetUserRoles("007");<br />}<br /><br />[TestMethod]<br />public void ShouldGetSuperSecretFromAgentUsingGenericPrincipalAndIdentity()<br />{<br />    var agent = new SecretAgent();<br /><br />    var secret = agent.GetSuperSecretStuff();<br /><br />    Assert.IsNotNull(secret);<br />}<br /><br />//SetUserRoles Method<br /><br /></code></pre><br />Now, this is certainly a lot better than the previous version since we only have to call SetUserRoles in one place. Also, our test method is free from the security clutter so we don't have any mental road blocks while reading the test. However, I am still not very happy with the end result. <br /><br /><b>Why?</b> <br /><br />Remember when I said I didn't want to have to <i>think</i> about the security while writing my tests? Well... I still do. Everytime I write a new method in my SUT, I will no doubt add another security attribute to it. Or, I will write a test to cover security, and then add the attribute to make my test pass. Either way, I will have to come back to the Init method and add another role to the list.<br /><br /><b>Nothing will cripple your unit testing efforts faster than brittle, hard to maintain tests!</b><br /><br />So how do we get around this? Ok so I already told you in Part 1 that we could build a custom Principal and Identity in order to achieve the desired results, but I wanted to expound a little on the rationale for actually doing it.<br /><br />In <a href="http://technofattie.blogspot.com/2012/01/its-principal.html">Part 3</a> we solve all our problems (I promise!)<br /></br><br /></br>
